### Pseudocode
### 1. Mine PATDBASE for .xml and T2 .dcm files
### 2.

### 1. Mine PATDBASE for .xml and T2 .dcm files
###     E:/PATDBASE
###          MRN -- 1st subfolder
###            date -- 2nd subfolder
###                 in this DIR there are 2 folders
###                      one of them has the T2 dicoms
###                      the other one has a bunch of folders including "REPORT"
###                         "REPORT" has the VISIT.xml

###    From DICOMs, get the accession number, MRN, image orientation patient
###      image position patient, xy pixel spacing, slice thickness, xyz dimensions
###      and 3D numpy matrix with pixel intensities

###    From VISIT.XMLs, get the version, core nums and locations, and transformed locations
###      ["core num", (x, y, z)_start, (x, y, z)_end]

### 1. Mine PATDBASE for .xml and T2 .dcm files

import numpy as np
import pandas as pd
import math
import os
import glob
import pydicom
import re
from Leofunctions import increment_filename
from Leofunctions import copyfile

#import matplotlib.pyplot as plt
import xml.etree.ElementTree as ET

# PATDBASE folder location
patdbasedir = 'H:\\PATDBASE'   #'E:\\patdbasetester' #'C:\\Users\\profuse\\Documents\\plotswcores\\patdbase' #'E:\\PATDBASE'
imagesdir = 'E:\\NPYimages' #'C:\\Users\\profuse\\Documents\\plotswcores\\NPYimages' #
datadir = 'E:\\patdbdata' #'C:\\Users\\profuse\\Documents\\plotswcores\\patdbdata' #'
segdir = 'C:\\ProcessedFusionImages\\segdicoms' #'C:\\Users\\profuse\\Documents\\plotswcores\\segdir'  #

savemri = False             #saves MRI as 3D numpy in 'imagesdir'
savedata = True            #saves core locations as numpys in 'datadir'
savecsv = True
savesegs = True
savenpy = False

if savemri == True:
    try:
        os.makedirs(imagesdir)
    except:
        print('Cannot make images directory (may already exist)')
if savedata == True:
    try:
        os.makedirs(datadir)
    except:
        print('Cannot make data directory (may already exist)')

def removeslash(string):
    string = string.replace('/', '')
    string = string.replace('\\', '')

    return string

def removedashandspace(string):
    string = string.replace(' ', '')
    string = string.replace('-', '')
    string = string.replace('_', '')

    return string

#################################################
### CALCULATE TRANSFORMATION FUNCTIONS ##########
#################################################
def calculatetransformmatrix(imgpospat, imageorientationpatient, pixelspacing, zspacing, nsize):
    # calculate transform based on imagepositionpatient, imageorientationpatient, nspacing, nsize
    # Returns tform                    transformation matrix
    #         lowerptslicererr         used in reorientpointreverse
    xvec = np.array(imgorientationpatient[0:3])
    yvec = np.array(imgorientationpatient[3:6])
    zvec = np.cross(xvec, yvec)

    nsize = np.array(nsize)

    nspacing = pixelspacing[:]
    nspacing.append(zspacing)
    nspacing = np.array(nspacing)

    tform = np.stack([xvec, yvec, zvec], axis=1)
    tform1 = np.zeros((4, 4))
    tform1[:3, :3] = tform
    tform1[3, 3] = 1
    tform = tform1.copy()

    lowerptslicererr = -np.floor(0.5*(nsize-1)) * nspacing
    lowerptslicer = -0.5 * (nsize-1) * nspacing
    lowerptslicer2 = np.ones(4)
    lowerptslicer2[0:3] = lowerptslicer
    lowerptslicerdicom = tform @ lowerptslicer2
    translation = imgpospat - lowerptslicerdicom[0:3]

    tform1 = np.eye(4)
    tform1[0:3, 3] = translation
    tform = tform1 @ tform

    return[tform, nsize, nspacing, lowerptslicererr]


def reorientpointreverse(loc, nsize, nspacing, slicerorg):
    # loc is np.array with 3 elements, (x, y, z); core location
    # nsize is np.array with x,y,z dimensions
    # nspacing is np.array with the pixel spacing and z slice thickness
    # slicerorg is np.array generated by calculatetransformation
    # RETURNS newloc: np.array with (x, y, z) coordinates of new location

    # CONVERTED FROM MATLAB CODE ###
    # function newLoc = ReorientPointReverse(loc,nSize,nSpacing,slicerOrg)
    #   idx = (loc(1:3) - [slicerOrg(2);slicerOrg(1);slicerOrg(3)])./[nSpacing(2);nSpacing(1);nSpacing(3)];
    #   newIdx = [idx(2);nSize(2)-idx(1)-1;idx(3)];
    #   newLoc = [slicerOrg + newIdx.*nSpacing;1];    # I don't incorporate the 4th dimension
    #  end
    slicerorg2 = slicerorg.copy()
    slicerorg2[0] = slicerorg[1]    # flips x and y coords
    slicerorg2[1] = slicerorg[0]

    nspacing2 = nspacing.copy()
    nspacing2[0] = nspacing[1]
    nspacing2[1] = nspacing[0]

    idx = (loc - slicerorg2)/nspacing2
    idx2 = idx.copy()
    idx2[0] = idx[1]
    idx2[1] = nsize[1] - idx[0] - 1
    newloc = slicerorg + idx2*nspacing

    return newloc


def transformcoreloc(corexyz, imgpospat, imgorientationpat, pixelspacing, zspacing, xyzdim):
    newcoreloc = np.array(corexyz)
    [tformmatrix, nsize, nspacing, slicerorg] = calculatetransformmatrix(imgpospat, imgorientationpat, pixelspacing, zspacing, xyzdim)
    newcoreloc = reorientpointreverse(newcoreloc, nsize, nspacing, slicerorg)
    newcoreloc = reorientpointreverse(newcoreloc, nsize, nspacing, slicerorg)
    newcoreloc2 = np.ones(4)
    newcoreloc2[0:3] = newcoreloc
    newcoreloc = tformmatrix @ newcoreloc2
    newcoreloc = newcoreloc[0:3]

    return newcoreloc

def gettransformedcores(sortedcoretips, sortedcorbots, minimgpositionpatient, imgorientationpatient, pixelspacing, zspacing, xyzdim):
    transformedcoretips = []
    transformedcorebots = []

    for i in range(len(sortedcoretips)):
        transformedcoretips.append(transformcoreloc(sortedcoretips[i], minimgpositionpatient, imgorientationpatient, pixelspacing, zspacing, xyzdim))
        transformedcorebots.append(transformcoreloc(sortedcorebots[i], minimgpositionpatient, imgorientationpatient, pixelspacing, zspacing, xyzdim))

    return [transformedcoretips, transformedcorebots]


######################################################
### PROCESS MR DIRECTORY #############################
######################################################
def processdicoms(mrdir):
    #processes MR folder and returns:
    #assessionnum, mrdate, slices, imgorientationpatient, imgpositionpatientarr, pixelspacing,
    #   zspacing, xyzdim, errormsg
    #if savenpy == True, then saves to npydir
    accessionnum = ''
    mrdate = ''
    slices = []
    imgorientationpatient = []
    imgpositionpatientarr = []
    pixelspacing = 0
    zspacing = 0
    xyzdim = []
    errormsgs = ''


    # finds all the MR files   labeled 'MR##'
    searchstr = mrdir + '/MR*'
    onlymrfiles = [f for f in glob.glob(searchstr)]

    if len(onlymrfiles) == 0:
        errormsgs = errormsgs + 'No MR files in folder; '
    else:
    # get imageorientationpatient, pixelspacing, accessionnum, mrdate from first slice
        try:
            ds = pydicom.read_file(onlymrfiles[0])
            pixelspacing = ds.PixelSpacing
            accessionnum = removedashandspace(ds.AccessionNumber)
            mrdate = ds.StudyDate
            firstpos = ds.ImagePositionPatient
            imgorientationpatient = ds.ImageOrientationPatient
            xvec = imgorientationpatient[0:3]
            yvec = imgorientationpatient[3:6]
            zvec = np.cross(xvec, yvec)

            ### figure out order of DICOM files
            ### arrange based on z coord of imagepositionpatient, negative to positive
            normdistances = []
            for i, mrfile in enumerate(onlymrfiles):
                ds = pydicom.read_file(mrfile)
                imgpositionpatient = np.array(ds.ImagePositionPatient)
                normdistances.append(np.dot(zvec, imgpositionpatient))

            # if distances are not approximately equal (< 10^-3 tolerance),
                # abort and output error MISSING SLICES
            sorteddistances = sorted(normdistances)
            distancediffs = []
            for i, distance in enumerate(sorteddistances):
                if i != 0:
                    distancediffs.append(sorteddistances[i] - sorteddistances[i-1])
            if abs(min(distancediffs) - max(distancediffs)) > 1e-3:
                errormsgs = 'MISSING SLICES (distances not equal); '
            else:    #if distances are equal to tolerance 1e-3
                # sort dicom files into sortedmris
                sortedi = sorted(range(len(normdistances)), key=lambda k: normdistances[k])
                sortedmris = []
                sortednormdistances = sorted(normdistances)
                for i, mrfile in enumerate(onlymrfiles):
                    sortedmris.append(onlymrfiles[sortedi[i]])

                ### go through dicom files in order to generate what we are looking for
                ##    From DICOMs, get the accession number, MRN, image orientation patient
                ###      image position patient, xy pixel spacing, slice thickness, xyz dimensions
                ###      and 3D numpy matrix with pixel intensities
                for i, mrfile in enumerate(sortedmris):
                    ds = pydicom.read_file(mrfile)
                    imgpositionpatientarr.append(ds.ImagePositionPatient)
                    slices.append(np.array(ds.pixel_array))

                #print(imgpositionpatientarr)

                mindistance = sortednormdistances[0]
                minimgpositionpatient = imgpositionpatientarr[0]
                zspacing = sortednormdistances[1] - sortednormdistances[0]

                # output np file with pixel array

                slices = np.stack(slices, axis=2)
                xyzdim = np.shape(slices)
        except:
            errormsgs = errormsgs + 'CANNOT READ DICOM; '

    return([accessionnum, mrdate, slices, imgorientationpatient, imgpositionpatientarr, pixelspacing, zspacing, xyzdim, errormsgs])

######################################################
### PROCESS XML DIRECTORY #############################
######################################################
def processxml(visitxmlpath):
    ### PROCESS XML File from visitxmlpath
    ###    From VISIT.XMLs, get the version, core nums and locations, and transformed locations
    ###    Returns lists: corenames   #.#  (instead of #-#)
    ###                   sortedcoretips  (sorted by corenames)
    ###                   sortedcorebots  ["core num", (x, y, z)_start, (x, y, z)_end]
    originalcorenames = []
    corenames = []
    coretips = []
    corebots = []
    sortedoriginalcorenames = []
    sortedcorenames = []
    sortedcoretips = []
    sortedcorebots = []
    errormsgs = ''
    version = ''

    try:
        root = ET.parse(visitxmlpath).getroot()
    except:
        errormsgs = errormsgs + 'CANNOT READ VISIT.XML; '
        return [version, sortedcorenames, sortedcoretips, sortedcorebots, errormsgs]


    targets = root.find('Targets')
    if targets == None:         #Version 1.4.0.0
        targets = root[1]
        version = root[0].text

        for target in targets:
            name = target.find('{http://www.eigen.com/Schemas/Artemis/0100/ArtemisTypes}Name').text
            location = target.find('{http://www.eigen.com/Schemas/Artemis/0100/ArtemisTypes}RecordedLocationInMR')

            if location == None:
                errormsgs = errormsgs + 'NO \'RecordedLocationInMR\' FOUND in VISIT.XML; '
            else:
                if re.search(r'\d{1,2}-\d', name) == None:
                    continue


                x = float(location[0].text)
                y = float(location[1].text)
                z = float(location[2].text)
                if x == 1000.0 and y == 1000.0 and z == 1000.0:
                    continue
                #if x == 1.12 and y == 15.26 and z == -22.15:
                #    continue

                start = target.find('{http://www.eigen.com/Schemas/Artemis/0100/ArtemisTypes}CorTipLocationInMR')
                start_x = float(start[0].text)
                start_y = float(start[1].text)
                start_z = float(start[2].text)

                end = target.find('{http://www.eigen.com/Schemas/Artemis/0100/ArtemisTypes}CorBotLocationInMR')
                end_x = float(end[0].text)
                end_y = float(end[1].text)
                end_z = float(end[2].text)

                flname = re.search(r'\d{1,2}-\d', name).group()
                flname = float(flname.replace('-', '.'))
                if 'ROI' in name:
                    flname = flname + 100

                originalcorenames.append(name)
                corenames.append(flname)
                coretips.append([start_x, start_y, start_z])
                corebots.append([end_x, end_y, end_z])

    else:           #Version 3+
        version = root.find('VisitVersion').text
        plan_targets = targets.findall('PlanTarget')

        for pt in plan_targets:
            shot_targets = pt.findall('ShotTarget')
            for st in shot_targets:
                name = st.find('Name').text.lower()
                location = st.find('RecordedLocationInMR')

                if location == None:
                    errormsgs = errormsgs + 'NO \'RecordedLocationInMR\' FOUND in VISIT.XML; '
                else:
                    if re.search(r'\d{1,2}-\d', name) == None:
                        continue

                    x = float(location.find('XValue').text)
                    y = float(location.find('YValue').text)
                    z = float(location.find('ZValue').text)
                    #if x == 1.12 and y == 15.26 and z == -22.15:
                    #        continue

                    start = st.find('CorTipLocationInMR')
                    start_x = float(start.find('XValue').text)
                    start_y = float(start.find('YValue').text)
                    start_z = float(start.find('ZValue').text)

                    end = st.find('CorBotLocationInMR')
                    end_x = float(end.find('XValue').text)
                    end_y = float(end.find('YValue').text)
                    end_z = float(end.find('ZValue').text)

                    ### searches for ##-#
                    ### if 'ROI' found, (targeted cores 1-5) will add 100 to core
                    ### so target ROI1 will be core 101

                    # ROI2-Site 1-2
                    if re.search(r'\d{1,2} c\ds\d-\d', name):
                        flname = re.search(r'\d{1,2}', name).group()
                        flname2 = re.search(r'\d{1,2} c\ds\d-\d', name).group().split('-')[1]
                        flname = flname + '.' + flname2
                        flname = float(flname)
                    elif re.search(r'\d{1,2}-\d', name):
                        flname = re.search(r'\d{1,2}-\d', name).group()
                        flname = float(flname.replace('-', '.'))
                        if 'roi1' in name:
                            flname = flname + 100
                        elif 'roi2' in name:
                            flname = flname + 101
                        elif 'roi3' in name:
                            flname = flname + 102
                        elif 'roi4' in name:
                            flname = flname + 103
                        elif 'roi5' in name:
                            flname = flname + 104
                        elif 'roi6' in name:
                            flname = flname + 105
                        elif 'roi7' in name:
                            flname = flname + 106
                        elif 'roi8' in name:
                            flname = flname + 107
                        elif 'roi9' in name:
                            flname = flnae + 108
                        elif 'roi' in name:
                            flname = flname + 100


                    if len(str(flname)) > 0:
                        originalcorenames.append(name)
                        corenames.append(flname)
                        coretips.append([start_x, start_y, start_z])
                        corebots.append([end_x, end_y, end_z])

    #print(corenames)

    try:
        corei = sorted(range(len(corenames)), key=lambda k: corenames[k])
        for i, core in enumerate(corei):
            sortedoriginalcorenames.append(originalcorenames[corei[i]])
            sortedcorenames.append(corenames[corei[i]])
            sortedcoretips.append(coretips[corei[i]])
            sortedcorebots.append(corebots[corei[i]])
    except:
        errormsgs = errormsgs + 'CORE NAME HAS NON-NUMERICAL CHARACTERS; '

    return [version, sortedoriginalcorenames, sortedcorenames, sortedcoretips, sortedcorebots, errormsgs]

# create dict based on accession number
###    From DICOMs, get the accession number, MRN, image orientation patient
###      image position patient, xy pixel spacing, slice thickness, xyz dimensions
###      and 3D numpy matrix with pixel intensities
accession_list = []
mrn_list = []
date_list = []              # date in PATDBASE (date of biopsy)
mrdate_list = []            # date in DICOM
xpixelspacing_list = []     # actually row spacing (DICOMs are rows, then columns)
ypixelspacing_list = []     # actually col spacing
zspacing_list = []
xdim_list = []              # actually num rows
ydim_list = []              # actually num cols
zdim_list = []
version_list = []
errormsgs_list = []
numcores_list = []

coresdf = []


### SEARCH FOR DIRECTORIES THAT HAVE REPORT AND MRDATA
### STORE INTO LIST: finaldirs
finaldirs = []

###          MRN -- 1st subfolder
mrnfolders = [f.path for f in os.scandir(patdbasedir) if f.is_dir()]


#mrndir = mrnfolders[1]
#if 1 == 1:
#######################################
for mrndir in mrnfolders:
    ###            date -- 2nd subfolder
    datefolders = [f.path for f in os.scandir(mrndir) if f.is_dir()]
    #datedir = datefolders[0]
    ########################################
    for datedir in datefolders:
        #visitdate = datedir[(len(mrndir)):]
        #visitdate = removeslash(visitdate)
        #print(visitdate)

        ###                 time -- 3rd subfolder
        timefolders = [f.path for f in os.scandir(datedir) if f.is_dir()]

        ### search for REPORT and MRDATA subfolders in timefolder
        ### if REPORT and MRDATA are present, then add that dir to list of dirs
        for timefolder in timefolders:
            if os.path.isdir(os.path.join(timefolder, 'REPORT')) and os.path.isdir(os.path.join(timefolder, 'MRDATA')):
                finaldirs.append(timefolder)


#print('Final Directories')
#print(finaldirs)
#print('-------------')


### Goes through all directories
#date = '20170908'
#mrn = '06321533'
#finaldir = 'E:/PATDBASE/38317525/20180119/105413'
#if True:
counter = -1

for finaldir in finaldirs:
    counter += 1
    if counter % 5 == 0:
        print(counter)

    slices = []
    errormsgs = ''
    version = ''
    mrdir = finaldir + '/MRDATA/VOLORG'
    visitxmlpath = finaldir + '/REPORT/VISIT.XML'
    segfile = os.path.join(finaldir, 'MRDATA/VOLORG/SEG')

    datedir = os.path.dirname(finaldir)
    mrndir = os.path.dirname(datedir)
    substr = os.path.dirname(mrndir)

    time = removeslash(finaldir.replace(datedir, ''))
    date = removeslash(datedir.replace(mrndir, ''))
    mrn = removeslash(mrndir.replace(substr, ''))

    mrn = removedashandspace(mrn)
    if '.2D.' in mrn:
        mrn = mrn.replace('.2D.', '')

    #print('MRN: ' + mrn + '   //   Date: ' + date + '    //    Time: ' + time)

    ###    From DICOMs, get the accession number, MRN, image orientation patient
    ###      image position patient, xy pixel spacing, zspacing, xyz dimensions
    ###    If savenp is True, then saves 3D numpy matrix with pixel intensities
    ###      to imagesdir
    [accessionnum, mrdate, mrnumpy, imgorientationpatient, imgpositionpatientarr, pixelspacing, zspacing, xyzdim, dcmerrormsgs] = processdicoms(mrdir)
    #print(accessionnum)

    if savesegs == True:
        newsegfilename = str(accessionnum) + '_' + str(mrdate) + '-0.seg'
        segdestpath = os.path.join(segdir, newsegfilename)
        try:
            copyfile(segfile, segdestpath)
        except:
            segfile = segfile + '.dcm'
            try:
                copyfile(segfile, segdestpath)
            except:
                print('No seg file found for mrn ' + str(mrn) + ' and date ' + str(date))

    errormsgs = errormsgs + dcmerrormsgs

    if errormsgs == '':
        # save npy file
        if savemri == True:
            np.save(os.path.join(imagesdir, str(accessionnum) + '_' + str(mrn) + '_' + str(date)), mrnumpy)
            print('MR slices written to numpy. Saved to: ' + str(imagesdir))

        # Process Visit.XML
        try:
            [version, originalcorenames, corenames, sortedcoretips, sortedcorebots, xmlerrormsgs] = processxml(visitxmlpath)
            numcores = len(corenames)
            errormsgs = errormsgs + xmlerrormsgs
        except:
            errormsgs = errormsgs + 'ERROR PROCESSING VISIT XML'

        # Get transformed cores (i.e. version 1.4 to version 1.5)
        if errormsgs == '':
            [transformedcoretips, transformedcorebots] = gettransformedcores(sortedcoretips, sortedcorebots, imgpositionpatientarr[0], imgorientationpatient, pixelspacing, zspacing, xyzdim)

        ### Save data
        ### one dimensional data will be saved to csv file with panda df
        ### multidimensional data will be saved as numpys
        ###    imagepositionpatient, ImageOrientationPatient
        ###    all core data (corenames, corebots, coretips, newcorebots, newcoretips)

            if savedata == True:
                # [mrn, MRaccession, biopsydate, MRdate, version, originalcorename, corename, coretipX, coretipY, coretipZ, corebotX, corebotY, corebotZ]
                for i, corename in enumerate(corenames):
                    originalcorename = originalcorenames[i]
                    [coretipX, coretipY, coretipZ] = sortedcoretips[i]
                    [corebotX, corebotY, corebotZ] = sortedcorebots[i]

                    coresdf.append(dict(zip(['mrn', 'MRaccession', 'biopsydate', 'MRdate', 'version', 'originalcorename', 'corename', 'coretipX', 'coretipY', 'coretipZ', 'corebotX', 'corebotY', 'corebotZ'], [mrn, accessionnum, date, mrdate, version, originalcorename, corename, coretipX, coretipY, coretipZ, corebotX, corebotY, corebotZ])))

                if savenpy == True:
                    imgpositionpatientarr = np.array(imgpositionpatientarr)
                    imgorientationpatient = np.array(imgorientationpatient)
                    corenames = np.array(corenames)
                    sortedcoretips = np.array(sortedcoretips)
                    sortedcorebots = np.array(sortedcorebots)
                    transformedcoretips = np.array(transformedcoretips)
                    transformedcorebots = np.array(transformedcorebots)

                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_imgpospat'), imgpositionpatientarr)
                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_imgoripat'), imgorientationpatient)
                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_corenames'), corenames)
                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_coretips'), sortedcoretips)
                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_corebots'), sortedcorebots)
                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_coretipsnew'), transformedcoretips)
                    np.save(os.path.join(datadir, str(accessionnum) + '_' + str(mrn) + '_' + str(date) + '_corebotsnew'), transformedcorebots)

                    print('Core data/DICOM coordinates numpy write successful. Data saved to ' + str(datadir) + '/' + str(accessionnum) + '_*')

    #print(corenames)

    accession_list.append(str(accessionnum))
    mrn_list.append(str(mrn))
    date_list.append(date)

    if errormsgs == '':
        mrdate_list.append(mrdate)
        version_list.append(version)
        xpixelspacing_list.append(pixelspacing[0])
        ypixelspacing_list.append(pixelspacing[1])
        zspacing_list.append(zspacing)
        xdim_list.append(xyzdim[0])
        ydim_list.append(xyzdim[1])
        zdim_list.append(xyzdim[2])
        numcores_list.append(numcores)
    else:
        mrdate_list.append('')
        version_list.append('')
        xpixelspacing_list.append(-1)
        ypixelspacing_list.append(-1)
        zspacing_list.append(-1)
        xdim_list.append(-1)
        ydim_list.append(-1)
        zdim_list.append(-1)
        numcores_list.append(0)

        print('ERROR in MRN: ' + mrn + '   DATE: ' + date)
        print('ERRORMSGS: ' + errormsgs)

    errormsgs_list.append(errormsgs)

    #print('-----------------------------------------')
    #print('')


# makes dataframe
outDF = pd.DataFrame(data = [accession_list, mrn_list, date_list, mrdate_list, version_list, errormsgs_list, numcores_list, xpixelspacing_list, ypixelspacing_list, zspacing_list, xdim_list, ydim_list, zdim_list])
outDF = outDF.transpose()
outDF.columns = ['accession', 'mrn', 'biopsydate', 'mrdate', 'version', 'errormsgs', 'numcores', 'rowspacing', 'colspacing', 'zspacing', 'rowdim', 'coldim', 'zdim']

coresdf2 = pd.DataFrame(coresdf)
coresdf2 = coresdf2[['mrn', 'MRaccession', 'biopsydate', 'MRdate', 'version', 'originalcorename', 'corename', 'coretipX', 'coretipY', 'coretipZ', 'corebotX', 'corebotY', 'corebotZ']]

# saves csv file
if savecsv == True:
    outDF.to_csv(os.path.join(datadir, 'patdbdata.csv'))
    print('CSV file write successful. Written to: ' + str(os.path.join(datadir, 'patdbdata.csv')))
    coresdf2.to_excel(os.path.join(datadir, 'coresXML.xls'))
